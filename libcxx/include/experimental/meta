// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Copyright 2024 Bloomberg Finance L.P.
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_EXPERIMENTAL_META
#define _LIBCPP_EXPERIMENTAL_META

/*
    experimental/meta synopsis

// C++2c
namespace std
{
namespace meta
{
inline namespace reflection_v2
{

// std::meta::info
using info = decltype(^int);

// concept reflection_range
template <typename R>
concept reflection_range = see below;

// name and location
template<typename T = u8string_view>
  consteval auto name_of(info) -> string_view;
template<typename T = u8string_view>
  consteval auto display_name_of(info) -> string_view;
template<typename T = u8string_view>
  consteval auto source_location_of(info r) -> source_location;

// type queries
consteval auto type_of(info) -> info;
consteval auto parent_of(info) -> info;
consteval auto dealias(info) -> info;

// value queries
consteval auto value_of(info) -> info;

// template queries
consteval auto template_of(info r) -> info;
consteval auto template_arguments_of(info r) -> vector<info>;

// member queries
template <typename... Preds>
  consteval auto members_of(info class_type, Preds... filters) -> vector<info>;
typename <template... Preds>
  consteval auto bases_of(info class_type, Preds... filters) -> vector<info>;
consteval auto static_data_members_of(info class_type) -> vector<info>;
consteval auto nonstatic_data_members_of(info class_type) -> vector<info>;
consteval auto subobjects_of(info class_type) -> vector<info>;
consteval auto enumerators_of(info enum_type) -> vector<info>;

// substitute
template <reflection_range R = span<info const>>
  consteval auto can_substitute(info templ, R &&args) -> bool;
template <reflection_range R = span<info const>>
  consteval auto substitute(info templ, R &&args) -> info;

// reflect_invoke
template <reflection_range R = span<info const>>
  consteval auto reflect_invoke(info target, R &&args) -> info;
template <reflection_range R1 = span<info const>,
          reflection_range R2 = span<info const>>
  consteval auto reflect_invoke(info target,
                                R1 &&tmpl_args, R2 &&args) -> info;

// reflect expression results
consteval auto reflect_value(auto) -> info;
consteval auto reflect_object(auto &) -> info;
consteval auto reflect_function(auto &) -> info;

// extract<T>
template <typename Ty>
  consteval auto extract(info) -> T;

// test_type
consteval auto test_type(info templ, info type) -> bool;
template <reflection_range R = span<info const>>
  consteval auto test_types(info templ, span<info const> types) -> bool;

// other type predicates
consteval auto is_public(info) -> bool;
consteval auto is_protected(info) -> bool;
consteval auto is_private(info) -> bool;
consteval auto is_accessible(info) -> bool;
consteval auto is_virtual(info) -> bool;
consteval auto is_pure_virtual(info) -> bool;
consteval auto is_override(info) -> bool;
consteval auto is_deleted(info) -> bool;
consteval auto is_defaulted(info) -> bool;
consteval auto is_explicit(info) -> bool;
consteval auto is_bit_field(info) -> bool;
consteval auto has_static_storage_duration(info) -> bool;
consteval auto has_internal_linkage(info) -> bool;
consteval auto has_external_linkage(info) -> bool;
consteval auto has_linkage(info) -> bool;
consteval auto is_class_member(info) -> bool;
consteval auto is_namespace_member(info) -> bool;
consteval auto is_nonstatic_data_member(info) -> bool;
consteval auto is_static_member(info) -> bool;
consteval auto is_base(info) -> bool;
consteval auto is_namespace(info) -> bool;
consteval auto is_function(info) -> bool;
consteval auto is_variable(info) -> bool;
consteval auto is_type(info) -> bool;
consteval auto is_alias(info) -> bool;
consteval auto is_incomplete_type(info) -> bool;
consteval auto is_template(info) -> bool;
consteval auto is_function_template(info) -> bool;
consteval auto is_variable_template(info) -> bool;
consteval auto is_class_template(bool) -> bool;
consteval auto is_alias_template(bool) -> bool;
consteval auto is_concept(info) -> bool;
consteval auto has_template_arguments(info) -> bool;
consteval auto is_constructor(info) -> bool;
consteval auto is_destructor(info) -> bool;
consteval auto is_special_member(info) -> bool;

// define_class
struct data_member_options_t;
consteval auto data_member_spec(info class_type,
                                data_member_options = {}) -> info;
template <reflection_range R = span<info const>>
  consteval auto define_class(info class_type, span<info const>) -> info;

// data layout
consteval auto offset_of(info) -> size_t;
consteval auto size_of(info) -> size_t;
consteval auto bit_offset_of(info) -> size_t;
consteval auto bit_size_of(info) -> size_t;
consteval auto alignment_of(info) -> size_t;

// function parameters (P3096)
consteval auto parameters_of(info) -> vector<info>;
consteval auto has_consistent_name(info) -> bool;
consteval auto has_default_argument(info) -> bool;

} // namespace reflection_v2
} // namespace meta
} // namespace std

 */

#include <experimental/__config>
#include <optional>
#include <ranges>
#include <source_location>
#include <span>
#include <string_view>
#include <type_traits>
#include <variant>
#include <vector>

#if __has_feature(reflection)

_LIBCPP_BEGIN_NAMESPACE_META_V2

// An opaque handle to a reflected entity.
using info = decltype(^int);

template <typename R>
concept reflection_range =
  ranges::input_range<R> &&
  same_as<ranges::range_value_t<R>, info> &&
  same_as<remove_cvref_t<ranges::range_reference_t<R>>, info>;

namespace detail {
enum : unsigned {

  // non-exposed metafunctions
  __metafn_get_begin_enumerator_decl_of,
  __metafn_get_get_next_enumerator_decl_of,
  __metafn_get_ith_base_of,
  __metafn_get_ith_template_argument_of,
  __metafn_get_begin_member_decl_of,
  __metafn_get_next_member_decl_of,
  __metafn_map_decl_to_entity,

  // exposed metafunctions
  __metafn_name_of,
  __metafn_display_name_of,
  __metafn_source_location_of,
  __metafn_type_of,
  __metafn_parent_of,
  __metafn_dealias,
  __metafn_value_of,
  __metafn_template_of,
  __metafn_can_substitute,
  __metafn_substitute,
  __metafn_extract,
  __metafn_is_public,
  __metafn_is_protected,
  __metafn_is_private,
  __metafn_is_accessible,
  __metafn_is_virtual,
  __metafn_is_pure_virtual,
  __metafn_is_override,
  __metafn_is_deleted,
  __metafn_is_defaulted,
  __metafn_is_explicit,
  __metafn_is_bit_field,
  __metafn_has_static_storage_duration,
  __metafn_has_internal_linkage,
  __metafn_has_external_linkage,
  __metafn_has_linkage,
  __metafn_is_class_member,
  __metafn_is_namespace_member,
  __metafn_is_nonstatic_data_member,
  __metafn_is_static_member,
  __metafn_is_base,
  __metafn_is_namespace,
  __metafn_is_function,
  __metafn_is_variable,
  __metafn_is_type,
  __metafn_is_alias,
  __metafn_is_incomplete_type,
  __metafn_is_template,
  __metafn_is_function_template,
  __metafn_is_variable_template,
  __metafn_is_class_template,
  __metafn_is_alias_template,
  __metafn_is_concept,
  __metafn_is_value,
  __metafn_is_object,
  __metafn_has_template_arguments,
  __metafn_is_constructor,
  __metafn_is_destructor,
  __metafn_is_special_member,
  __metafn_reflect_result,
  __metafn_reflect_invoke,
  __metafn_data_member_spec,
  __metafn_define_class,
  __metafn_offset_of,
  __metafn_size_of,
  __metafn_bit_offset_of,
  __metafn_bit_size_of,
  __metafn_alignment_of,

  // P3096 metafunctions
  __metafn_get_ith_parameter_of,
  __metafn_has_consistent_name,
  __metafn_has_default_argument,
};

}  // namespace detail

namespace __range_of_infos {

constexpr struct always_true_fn {
  consteval bool operator()(info) {
    return true;
  }
} always_true;

struct sentinel {};

template <typename Front, typename Next, typename Map,
          typename Pred = always_true_fn>
class iterator {
  static constexpr Front m_front = { };
  static constexpr Next m_next = { };

  // The reflected entity passed to the underlying range
  info m_reflectedEntity{^sentinel};
  // The current meta::info within the range: e.g. if we are
  // doing template_arguments_of(^std::vector<int, double, std::string>)
  // m_currInfoItr can be either ^int, ^double and ^std::string
  info m_currInfoItr{^sentinel};

  Pred m_pred;
  Map m_mapFn;
  size_t m_nextIndex {0};

  consteval void advance() {
    while ((m_currInfoItr != ^sentinel) && !m_pred(m_mapFn(m_currInfoItr)))
      m_currInfoItr = m_next(m_currInfoItr, m_reflectedEntity, m_nextIndex++);
  }

public:
  using value_type = info;
  using reference = info;
  using pointer = info;
  using difference_type = ptrdiff_t;
  using iterator_category = forward_iterator_tag;
  using filter_type = Pred;

  consteval iterator(Pred pred)
    : m_currInfoItr{^sentinel}
    , m_pred{pred}
    , m_mapFn{}
  { }

  consteval iterator(meta::info reflectedEntity, Pred pred)
    : m_reflectedEntity{reflectedEntity}
    , m_currInfoItr{m_front(reflectedEntity)}
    , m_pred{pred}
    , m_nextIndex{1} // after we fetch the front, next index is 1
  {
    advance();
  }

  consteval info operator*() const {
    return m_mapFn(m_currInfoItr);
  }

  // pre-incr ++itr;
  consteval iterator operator++() {
    m_currInfoItr = m_next(m_currInfoItr, m_reflectedEntity, m_nextIndex++);
    advance();
    return *this;
  }

  // post-incr itr++;
  consteval iterator operator++(int) {
    iterator tmp = *this;
    operator++();
    return tmp;
  }

  consteval Pred filter() const {
    return m_pred;
  }

  consteval friend bool operator==(iterator a, iterator b) {
    return a.m_currInfoItr == b.m_currInfoItr;
  }

  consteval friend bool operator!=(iterator a, iterator b) {
    return a.m_currInfoItr != b.m_currInfoItr;
  }
};

template <typename Iter>
class range {
  Iter m_first;
  Iter m_last;

public:
  using iterator = Iter;
  using filter_type = typename Iter::filter_type;

  consteval range(info reflection, filter_type pred = {})
    : m_first(reflection, pred) , m_last(pred)
  { }

  consteval iterator begin() const
  {
    return m_first;
  }

  consteval iterator end() const
  {
    return m_last;
  }
};

template <typename Front, typename Next, typename Map, typename Pred>
consteval ptrdiff_t distance(iterator<Front, Next, Map, Pred> first,
                             iterator<Front, Next, Map, Pred> last) {
  ptrdiff_t n = 0;
  for (; first != last; ++first)
    ++n;
  return n;
}

constexpr struct next_member_of_fn {
  consteval info operator()(info currItrInfo, auto /* reflectedEntity */,
                            auto /* idx */) const {
    return __metafunction(detail::__metafn_get_next_member_decl_of, currItrInfo,
                          ^sentinel);
  }
} next_member;

constexpr struct front_member_of_fn {
  consteval info operator()(info reflectedEntity) const {
    return __metafunction(detail::__metafn_get_begin_member_decl_of,
                          reflectedEntity, ^sentinel);
  }
} front_member;

constexpr struct map_decl_to_entity_fn {
  consteval info operator()(info reflectedDecl) const {
    return __metafunction(detail::__metafn_map_decl_to_entity, reflectedDecl);
  }
} map_decl_to_entity;

constexpr struct map_identity_fn {
  consteval info operator()(info reflectedDecl) const {
    return reflectedDecl;
  }
} map_identity;

constexpr struct next_targ_fn {
  consteval info operator()(auto /* currItrInfo */, info reflectedEntity,
                            size_t idx) const {
    return __metafunction(detail::__metafn_get_ith_template_argument_of,
                          reflectedEntity, ^sentinel, idx);
  }
} next_targ;

constexpr struct front_targ_fn {
  consteval info operator()(info reflectedEntity) const {
    return __metafunction(detail::__metafn_get_ith_template_argument_of,
                          reflectedEntity, ^sentinel, 0);
  }
} front_targ;

constexpr struct next_base_of_fn {
  consteval info operator()(auto /* currItrInfo */, info reflectedEntity,
                            size_t idx) const {
    return __metafunction(detail::__metafn_get_ith_base_of,
                          reflectedEntity, ^sentinel, idx);
  }
} next_base;

constexpr struct front_base_of_fn {
  consteval info operator()(info reflectedEntity) const {
    return __metafunction(detail::__metafn_get_ith_base_of,
                          reflectedEntity, ^sentinel, 0);
  }
} front_base;

constexpr struct next_enumerator_of_fn {
  consteval info operator()(info currItrInfo, auto /* reflectedEntity */,
                            auto /* idx */ ) const {
    
    return __metafunction(detail::__metafn_get_get_next_enumerator_decl_of,
                          currItrInfo, ^sentinel);
  }
} next_enumerator;

constexpr struct front_enumerator_of_fn {
  consteval info operator()(info reflectedEntity) const {
    return __metafunction(detail::__metafn_get_begin_enumerator_decl_of,
                          reflectedEntity, ^sentinel);
  }
} front_enumerator;

#if __has_feature(parameter_reflection)

struct next_parameter_of_fn {
  consteval info operator()(auto /* currItrInfo */, info reflectedEntity,
                            size_t idx) const {
    return __metafunction(detail::__metafn_get_ith_parameter_of,
                          reflectedEntity, ^sentinel, idx);
  }
};

struct front_parameter_of_fn {
  consteval info operator()(info reflectedEntity) const {
    return __metafunction(detail::__metafn_get_ith_parameter_of,
                          reflectedEntity, ^sentinel, 0);
  }
};

#endif  // __has_feature(parameter_reflection)

}  // namespace __range_of_infos

// -----------------------------------------------------------------------------
// Metafunctions
// -----------------------------------------------------------------------------

// Returns the name of the reflected entity, or the empty string if it has none.
template<typename T = u8string_view>
consteval auto name_of(info r) -> T {
  static_assert(^T == ^u8string_view || ^T == ^string_view,
                "Name type must be 'string_view' or 'u8string_view'");

  return __metafunction(detail::__metafn_name_of,
                        ^const typename T::value_type *, r,
                        ^T == ^std::u8string_view);
}

// Returns a name for the reflected entity.
template<typename T = u8string_view>
consteval auto display_name_of(info r) -> T {
  static_assert(^T == ^u8string_view || ^T == ^string_view,
                "Name type must be 'string_view' or 'u8string_view'");

  return __metafunction(detail::__metafn_display_name_of,
                        ^const typename T::value_type *, r,
                        ^T == ^std::u8string_view);
}

// Returns the source location of the reflected entity.
consteval auto source_location_of(info r) -> source_location {
  auto ptr = __metafunction(detail::__metafn_source_location_of, r);
  return source_location::current(ptr);
}

// Returns the type of the provided reflection of an expression.
consteval auto type_of(info r) -> info {
  return __metafunction(detail::__metafn_type_of, r);
}

// Returns the containing class or namespace of a class or namespace member.
consteval auto parent_of(info r) -> info {
  return __metafunction(detail::__metafn_parent_of, r);
}

// Returns a reflection of the canonical type for the reflected type.
consteval auto dealias(info r) -> info {
  return __metafunction(detail::__metafn_dealias, r);
}

// Returns a reflection of the value evaluated from the reflected entity.
consteval auto value_of(info r) -> info {
  return __metafunction(detail::__metafn_value_of, r);
}

// Returns a reflection of the template from which the reflected entity was
// instantiated.
consteval auto template_of(info r) -> info {
  return __metafunction(detail::__metafn_template_of, r);
}

consteval auto template_arguments_of(info r) -> vector<info> {
  using iterator =
      __range_of_infos::iterator<__range_of_infos::front_targ_fn,
                                 __range_of_infos::next_targ_fn,
                                 __range_of_infos::map_identity_fn>;
  using range = __range_of_infos::range<iterator>;
  auto rng = range{r};
  return vector<info>{rng.begin(), rng.end()};
}

// Returns whether the reflected entity is a member of a class.
consteval auto is_class_member(info r) -> bool {
  return __metafunction(detail::__metafn_is_class_member, r);
}


// Returns whether the reflected entity is a non-static data member.
consteval auto is_nonstatic_data_member(info r) -> bool {
  return is_class_member(r) &&
         __metafunction(detail::__metafn_is_nonstatic_data_member, r);
}

// Returns whether the reflected entity is a static member.
consteval auto is_static_member(info r) -> bool {
  return is_class_member(r) &&
         __metafunction(detail::__metafn_is_static_member, r);
}

// Returns whether the reflected entity is a base class specifier.
consteval auto is_base(info r) -> bool {
  return __metafunction(detail::__metafn_is_base, r);
}

template <typename Pred>
consteval auto members_of(info r, Pred pred) {
  using iterator =
      __range_of_infos::iterator<__range_of_infos::front_member_of_fn,
                                 __range_of_infos::next_member_of_fn,
                                 __range_of_infos::map_decl_to_entity_fn, Pred>;
  using range = __range_of_infos::range<iterator>;
  auto rng = range{r, pred};
  return vector<info>{rng.begin(), rng.end()};
}

template <typename... Preds>
consteval auto members_of(info r, Preds... preds) {
  return members_of(r, [&](info r) {
    return (preds(r) && ...);
  });
}

consteval auto members_of(info r) -> vector<info> {
  return members_of(r, __range_of_infos::always_true);
}

// Returns whether the reflected entity is a namespace.
consteval auto is_namespace(info r) -> bool {
  return __metafunction(detail::__metafn_is_namespace, r);
}

template <typename Pred>
consteval auto bases_of(info r, Pred pred) -> vector<info> {
  if (is_namespace(r))
    throw "Namespaces cannot have base classes";

  using iterator =
    __range_of_infos::iterator<__range_of_infos::front_base_of_fn,
                                __range_of_infos::next_base_of_fn,
                                __range_of_infos::map_identity_fn, Pred>;
  using range = __range_of_infos::range<iterator>;
  auto rng = range{r, pred};
  return vector<info>{rng.begin(), rng.end()};
}

template <typename... Preds>
consteval auto bases_of(info r, Preds... preds) -> vector<info> {
  return bases_of(r, [&](info r) {
    return (preds(r) && ...);
  });
}

consteval auto bases_of(info r) -> vector<info> {
  return bases_of(r, __range_of_infos::always_true);
}

// Returns whether the reflected entity is a variable.
consteval auto is_variable(info r) -> bool {
  return __metafunction(detail::__metafn_is_variable, r);
}

consteval auto static_data_members_of(info r) -> vector<info> {
  if (is_namespace(r))
    throw "Namespaces cannot have static data members";

  return members_of(r, is_class_member, is_variable);
}

consteval auto nonstatic_data_members_of(info r) -> vector<info> {
  if (is_namespace(r))
    throw "Namespaces cannot have non-static data members";

  return members_of(r, is_nonstatic_data_member);
}

consteval auto subobjects_of(info r) -> vector<info> {
  if (is_namespace(r))
    throw "Namespaces cannot have subobjects";

  auto subobjects = bases_of(r);
  subobjects.append_range(nonstatic_data_members_of(r));
  return subobjects;
}

consteval auto enumerators_of(info r) -> vector<info> {
  using iterator =
    __range_of_infos::iterator<__range_of_infos::front_enumerator_of_fn,
                               __range_of_infos::next_enumerator_of_fn,
                               __range_of_infos::map_identity_fn>;
  using range = __range_of_infos::range<iterator>;
  auto rng = range{r};
  return vector<info>{rng.begin(), rng.end()};
}

// Returns whether 'templ' substituted with 'args' forms a valid template-id.
template <reflection_range R = span<info const>>
consteval auto can_substitute(info templ, R &&args) -> bool {
  if constexpr (ranges::contiguous_range<R>) {
    return __metafunction(detail::__metafn_can_substitute, templ,
                          ranges::data(args), ranges::size(args));
  } else {
    vector vargs = args | ranges::to<vector>();
    return __metafunction(detail::__metafn_can_substitute, templ,
                          vargs.data(), vargs.size());
  }
}

// Returns a reflection representing the template instantiation of the entity
// reflected by 'templ' with the entities reflected by 'args'.
template <reflection_range R = span<info const>>
consteval auto substitute(info templ, R &&args) -> info {
  if constexpr (ranges::contiguous_range<R>) {
    return __metafunction(detail::__metafn_substitute, templ,
                          ranges::data(args), ranges::size(args));
  } else {
    vector vargs = args | ranges::to<vector>();
    return __metafunction(detail::__metafn_substitute, templ, vargs.data(),
                          vargs.size());
  }
}

// Returns the value or object from 'r' if 'r' is a reflection of a value
// or object having type 'T'.
template <typename Ty> requires (!is_rvalue_reference_v<Ty>)
consteval auto extract(info r) -> Ty {
  return __metafunction(detail::__metafn_extract, ^Ty, r);
}

template <reflection_range R = span<info const>>
consteval auto test_types(info templ, R &&args) -> bool {
  return extract<bool>(substitute(templ, args));
}

consteval auto test_type(info templ, info type) -> bool {
  info args[1] = {type};
  return test_types(templ, args);
}

// Returns whether the reflected entity is a public class member.
consteval auto is_public(info r) -> bool {
  return __metafunction(detail::__metafn_is_public, r);
}

// Returns whether the reflected entity is a protected class member.
consteval auto is_protected(info r) -> bool {
  return __metafunction(detail::__metafn_is_protected, r);
}

// Returns whether the reflected entity is a private class member.
consteval auto is_private(info r) -> bool {
  return __metafunction(detail::__metafn_is_private, r);
}

// Returns whether the reflected entity can be accessed from the callsite.
consteval auto is_accessible(info r) -> bool {
  return __metafunction(detail::__metafn_is_accessible, r);
}

// Returns whether the reflected entity is a virtual member function or a
// virtual base class.
consteval auto is_virtual(info r) -> bool {
  return __metafunction(detail::__metafn_is_virtual, r);
}

// Returns whether the reflected class member function is pure virtual.
consteval auto is_pure_virtual(info r) -> bool {
  return __metafunction(detail::__metafn_is_pure_virtual, r);
}

// Returns whether the reflected class member function overrides a virtual
// member function from a base class.
consteval auto is_override(info r) -> bool {
  return __metafunction(detail::__metafn_is_override, r);
}

// Returns whether the reflected class member function is deleted.
consteval auto is_deleted(info r) -> bool {
  return __metafunction(detail::__metafn_is_deleted, r);
}

// Returns whether the reflected class member function is defaulted.
consteval auto is_defaulted(info r) -> bool {
  return __metafunction(detail::__metafn_is_defaulted, r);
}

// Returns whether the reflected class member function is explicit.
consteval auto is_explicit(info r) -> bool {
  return __metafunction(detail::__metafn_is_explicit, r);
}

// Returns whether the reflected class data member is a bit field.
consteval auto is_bit_field(info r) -> bool {
  return __metafunction(detail::__metafn_is_bit_field, r);
}

// Returns whether the reflected entity is a variable having static storage
// duration.
consteval auto has_static_storage_duration(info r) -> bool {
  return __metafunction(detail::__metafn_has_static_storage_duration, r);
}

// Returns whether the reflected entity has internal linkage.
consteval auto has_internal_linkage(info r) -> bool {
  return __metafunction(detail::__metafn_has_internal_linkage, r);
}

// Returns whether the reflected entity has external linkage.
consteval auto has_external_linkage(info r) -> bool {
  return __metafunction(detail::__metafn_has_external_linkage, r);
}

// Returns whether the reflected entity has linkage.
consteval auto has_linkage(info r) -> bool {
  return __metafunction(detail::__metafn_has_linkage, r);
}

// Returns whether the reflected entity is a member of a namespace.
consteval auto is_namespace_member(info r) -> bool {
  return __metafunction(detail::__metafn_is_namespace_member, r);
}

// Returns whether the reflected entity is a function.
consteval auto is_function(info r) -> bool {
  return __metafunction(detail::__metafn_is_function, r);
}

// Returns whether the reflected entity is a type.
consteval auto is_type(info r) -> bool {
  return __metafunction(detail::__metafn_is_type, r);
}

// Returns true if the reflected entity is an alias.
consteval auto is_alias(info r) -> bool {
  return __metafunction(detail::__metafn_is_alias, r);
}

// Returns true if the reflected entity is an incomplete type.
consteval auto is_incomplete_type(info r) -> bool {
  return __metafunction(detail::__metafn_is_incomplete_type, r);
}

// Returns true if the reflected entity is a template.
consteval auto is_template(info r) -> bool {
  return __metafunction(detail::__metafn_is_template, r);
}

// Returns true if the reflected entity is a function template.
consteval auto is_function_template(info r) -> bool {
  return __metafunction(detail::__metafn_is_function_template, r);
}

// Returns true if the reflected entity is a variable template.
consteval auto is_variable_template(info r) -> bool {
  return __metafunction(detail::__metafn_is_variable_template, r);
}

// Returns true if the reflected entity is a class template.
consteval auto is_class_template(info r) -> bool {
  return __metafunction(detail::__metafn_is_class_template, r);
}

// Returns true if the reflected entity is an alias template.
consteval auto is_alias_template(info r) -> bool {
  return __metafunction(detail::__metafn_is_alias_template, r);
}

// Returns true if the reflected entity is a concept.
consteval auto is_concept(info r) -> bool {
  return __metafunction(detail::__metafn_is_concept, r);
}

// Returns true if the reflected entity is a value.
consteval auto is_value(info r) -> bool {
  return __metafunction(detail::__metafn_is_value, r);
}

// Returns true if the reflected entity is an object.
consteval auto is_object(info r) -> bool {
  return __metafunction(detail::__metafn_is_object, r);
}

// Returns if the type has template arguments
consteval auto has_template_arguments(info r) -> bool {
  return __metafunction(detail::__metafn_has_template_arguments, r);
}

// Returns whether the reflected entity is a constructor.
consteval auto is_constructor(info r) -> bool {
  return __metafunction(detail::__metafn_is_constructor, r);
}

// Returns whether the reflected entity is a destructor.
consteval auto is_destructor(info r) -> bool {
  return __metafunction(detail::__metafn_is_destructor, r);
}

// Returns whether the reflected entity is a special member function.
consteval auto is_special_member(info r) -> bool {
  return __metafunction(detail::__metafn_is_special_member, r);
}

// Returns a reflection of the value held by the provided argument.
consteval auto reflect_value(auto r) -> info {
  static_assert(!is_reference_v<decltype(r)>,
                "values cannot have reference type");

  constexpr info Ty = type_of(^r);

  return __metafunction(detail::__metafn_reflect_result, Ty,
                        static_cast<typename [:Ty:]>(r));
}

// Returns a reflection of the object designated by the provided argument.
consteval auto reflect_object(auto &r) -> info {
  static_assert(is_lvalue_reference_v<decltype(r)>,
                "objects must be designated by lvalue references");

  constexpr auto Ty = type_of(^r);

  static_assert(!is_function_v<remove_reference<typename [:Ty:]>>,
                "use 'reflect_function' for references to functions");
  return __metafunction(detail::__metafn_reflect_result, Ty, r);
}

// Returns a reflection of the object designated by the provided argument.
consteval auto reflect_function(auto &r) -> info {
  static_assert(is_lvalue_reference_v<decltype(r)>,
                "functions must be designated by lvalue references");

  constexpr auto Ty = type_of(^r);
  using UnrefTy = remove_reference_t<[:Ty:]>;

  constexpr bool IsPtr = is_pointer_v<UnrefTy>;
  static_assert(!IsPtr, "use 'reflect_value' for pointers to functions");
  if constexpr (!IsPtr)
    static_assert(is_function_v<UnrefTy>,
                  "use 'reflect_object' for references to objects");

  return __metafunction(detail::__metafn_reflect_result, Ty, r);
}


// Returns a reflection of the constant value obtained from calling
//   target(args...)
template <reflection_range R = span<info const>>
consteval auto reflect_invoke(info target, R &&args) -> info {
  if constexpr (ranges::contiguous_range<R>) {
    return __metafunction(detail::__metafn_reflect_invoke, target,
                          static_cast<std::meta::info *>(nullptr), 0,
                          ranges::data(args), ranges::size(args));
  } else {
    vector vargs = args | ranges::to<vector>();
    return __metafunction(detail::__metafn_reflect_invoke, target,
                          static_cast<std::meta::info *>(nullptr), 0,
                          vargs.data(), vargs.size());
  }
}

template <reflection_range R1 = span<info const>,
          reflection_range R2 = span<info const>>
consteval auto reflect_invoke(info target, R1 &&targs, R2 &&args) -> info {
  if constexpr (ranges::contiguous_range<R1>) {
    if constexpr (ranges::contiguous_range<R2>) {
      return __metafunction(detail::__metafn_reflect_invoke, target,
                            ranges::data(targs), ranges::size(targs),
                            ranges::data(args), ranges::size(args));
    } else {
      vector vargs = args | ranges::to<vector>();
      return __metafunction(detail::__metafn_reflect_invoke, target,
                            ranges::data(targs), ranges::size(targs),
                            vargs.data(), vargs.size());
    }
  } else {
    vector vtargs = targs | ranges::to<vector>();
    if constexpr (ranges::contiguous_range<R2>) {
      return __metafunction(detail::__metafn_reflect_invoke, target,
                            vtargs.data(), vtargs.size(),
                            ranges::data(args), ranges::size(args));
    } else {
      vector vargs = args | ranges::to<vector>();
      return __metafunction(detail::__metafn_reflect_invoke, target,
                            vtargs.data(), vtargs.size(),
                            vargs.data(), vargs.size());
    }
  }
}

// Representation of a data member which may be passed to 'data_member_spec'.
struct data_member_options_t {
  struct name_type {
    std::variant<u8string, string> impl;

    template <typename T> requires constructible_from<u8string, T>
    consteval name_type(T &&in) : impl(std::in_place_type<u8string>, in) {}

    template <typename T> requires constructible_from<string, T>
    consteval name_type(T &&in) : impl(std::in_place_type<string>, in) {}
  };

  optional<name_type> name = nullopt;
  bool is_static = false;
  optional<int> alignment = nullopt;
  optional<int> width = nullopt;
};

// Returns a reflection representing a description of a data member, which may
// be used with 'define_class' to define a record type.
consteval auto data_member_spec(info member_type,
                                data_member_options_t options = {}) -> info {
  auto name = options.name.value_or(u8"").impl;
  bool is_static = options.is_static;
  int alignment = options.alignment.value_or(0);
  int width = options.width.value_or(0);

  if (holds_alternative<u8string>(name)) {
    const u8string &s = get<u8string>(name);
    return __metafunction(detail::__metafn_data_member_spec,
                          member_type, is_static, options.name.has_value(),
                          s.size(), ^const char8_t *, s.data(),
                          options.alignment.has_value(), alignment,
                          options.width.has_value(), width);
  } else {
    const string &s = get<string>(name);
    return __metafunction(detail::__metafn_data_member_spec,
                          member_type, is_static, options.name.has_value(),
                          s.size(), ^const char *, s.data(),
                          options.alignment.has_value(), alignment,
                          options.width.has_value(), width);
  }
}

// Completes the definition of the record type reflected by 'class_type' with
// the members described by the reflections in the provided span.
template <reflection_range R = span<info const>>
consteval auto define_class(info class_type, R &&members) -> info {
  if constexpr (ranges::contiguous_range<R>) {
    return __metafunction(detail::__metafn_define_class, class_type,
                          ranges::size(members), ranges::data(members));
  } else {
    vector vmembers = members | ranges::to<vector>();
    return __metafunction(detail::__metafn_define_class, class_type,
                          vmembers.size(), vmembers.data());
  }
}

// Returns the offset of the reflected entity.
consteval auto offset_of(info r) -> size_t {
  return __metafunction(detail::__metafn_offset_of, r);
}

// Returns the size of the reflected entity.
consteval auto size_of(info r) -> size_t {
  return __metafunction(detail::__metafn_size_of, r);
}


consteval auto bit_offset_of(info r) -> size_t {
  return __metafunction(detail::__metafn_bit_offset_of, r);
}

// Returns the size of the reflected entity in bits.
consteval auto bit_size_of(info r) -> size_t {
  return __metafunction(detail::__metafn_bit_size_of, r);
}

// Returns the alignment of the reflected entity.
consteval auto alignment_of(info r) -> size_t {
  return __metafunction(detail::__metafn_alignment_of, r);
}

#if __has_feature(parameter_reflection)

consteval auto parameters_of(info r) -> vector<info> {
  using iterator =
    __range_of_infos::iterator<__range_of_infos::front_parameter_of_fn,
                                __range_of_infos::next_parameter_of_fn,
                                __range_of_infos::map_identity_fn>;
  using range = __range_of_infos::range<iterator>;
  auto rng = range{r};
  return vector<info>{rng.begin(), rng.end()};
}

consteval auto has_consistent_name(info r) -> bool {
  return __metafunction(detail::__metafn_has_consistent_name, r);
}

consteval auto has_default_argument(info r) -> bool {
  return __metafunction(detail::__metafn_has_default_argument, r);
}

#endif  // __has_feature(parameter_reflection)

template <typename Ty>
[[deprecated("separated into 'reflect_value', 'reflect_result', and "
             "'reflect_function' in P2996R4")]]
consteval auto reflect_result(Ty r) -> info {
  constexpr auto DTy = dealias(^Ty);
  constexpr auto RTy = is_class_v<[:DTy:]> || is_reference_v<[:DTy:]> ?
                       DTy : ^remove_cv_t<[:DTy:]>;

  return __metafunction(detail::__metafn_reflect_result, dealias(RTy),
                        static_cast<typename [:DTy:]>(r));
}

_LIBCPP_END_NAMESPACE_META_V2

#endif  // __has_feature(reflection)

#endif  // _LIBCPP_EXPERIMENTAL_META
